#include <MD_TCS230.h>
#include <FreqCount.h>
#include "ColorMatch.h"

#define BLACK_CAL 0
#define WHITE_CAL 1
#define READ_VAL 2
#define LEARN_VAL 3

// Pin definitions
//S0, S1, LED to pins 2, 3, 4 (No particular order)
#define S2_OUT 11 //S2 pin
#define S3_OUT 12 //S3 pin
#define OE_OUT 8  // LOW = ENABLED (Not used)

MD_TCS230 CS(S2_OUT, S3_OUT, OE_OUT);

// Global variables
uint8_t ctIndex;
colorData rgb;

void setup()
{
  Serial.begin(57600);

  for (int i = 2; i <= 4; i++)
  {
    pinMode(i, OUTPUT);
    digitalWrite(i, HIGH);
  }

  Serial.print(F("\n[TCS230 Calibrator Example]"));

  // initialise color sensor
  CS.begin();
}

char getChar()
// blocking wait for an input character from the input stream
{
  while (Serial.available() == 0)
    ;
  return (toupper(Serial.read()));
}

void clearInput()
// clear out serial input
{
  while (Serial.read() != -1)
    ;
}

char *readASCII(uint8_t size)
// read up to size-1 characters from the serial input
// this is quick and dirty code
{
#define BUF_SIZE 12
  static char s[BUF_SIZE];
  uint8_t i = 0;
  char c;

  s[0] = '\0';
  size--;
  while ((i < size) && (size < BUF_SIZE - 1))
  {
    c = getChar();
    if (c == '\n')
      break;
    s[i++] = c;
    s[i] = '\0';
  }

  clearInput();

  return (s);
#undef BUF_SIZE
}

void outputHeader(void)
{
  Serial.println("");
  Serial.print(F("\n// Header file for the ColorMatch application"));
  Serial.print(F("\n// This file is generated by the ColorMatch Application in Learn Mode"));

  Serial.print(F("\n\n// Calibration data"));
  Serial.print(F("\nsensorData sdBlack = { "));
  Serial.print(sdBlack.value[0]);
  Serial.print(F(", "));
  Serial.print(sdBlack.value[1]);
  Serial.print(F(", "));
  Serial.print(sdBlack.value[2]);
  Serial.print(F(" };"));

  Serial.print(F("\nsensorData sdWhite = { "));
  Serial.print(sdWhite.value[0]);
  Serial.print(F(", "));
  Serial.print(sdWhite.value[1]);
  Serial.print(F(", "));
  Serial.print(sdWhite.value[2]);
  Serial.print(F(" };"));

  Serial.print(F("\n\n// Color Table for matching"));
  Serial.print(F("\ntypedef struct\n{\n  char    name[9];  // color name 8+nul\n  colorData rgb;    // RGB value\n} colorTable;"));

  Serial.print(F("\n\ncolorTable ct[] = \n{"));
  for (uint8_t i = 0; i < ARRAY_SIZE(ct); i++)
  {
    Serial.print(F("\n  {\""));
    Serial.print(ct[i].name);
    Serial.print(F("\", {"));
    Serial.print(ct[i].rgb.value[0]);
    Serial.print(F(", "));
    Serial.print(ct[i].rgb.value[1]);
    Serial.print(F(", "));
    Serial.print(ct[i].rgb.value[2]);
    Serial.print(F("} },"));
  }
  Serial.print(F("\n};\n"));
}

uint8_t fsmReadValue(uint8_t state, uint8_t valType)
{
  static uint8_t selChannel;
  static uint8_t readCount;
  static sensorData sd;

  switch (state)
  {
    case 0: // Prompt for the user to start
      Serial.print(F("\n\nReading value for "));

      switch (valType)
      {
        case BLACK_CAL:
          Serial.print(F("BLACK calibration"));
          break;
        case WHITE_CAL:
          Serial.print(F("WHITE calibration"));
          break;
        case LEARN_VAL:
          Serial.print(ct[ctIndex].name);
          break;
        default:
          Serial.print(F("??"));
          break;
      }

      clearInput();

      Serial.print(F("\nPress any key to start ..."));
      getChar();
      clearInput();

    case 1: // start the reading process
      CS.read();
      state++;
      break;

    case 2: // wait for a read to complete
      if (CS.available())
      {
        switch (valType)
        {
          case BLACK_CAL:
            CS.getRaw(&sdBlack);
            CS.setDarkCal(&sdBlack);
            break;

          case WHITE_CAL:
            CS.getRaw(&sdWhite);
            CS.setWhiteCal(&sdWhite);
            break;
        }
        state++;
      }
      break;

    default: // reset fsm
      state = 0;
      break;
  }

  return (state);
}

void loop()
{
  static uint8_t runState = 0;
  static uint8_t readState = 0;

  switch (runState)
  {
    case 0: // calibrate black
      readState = fsmReadValue(readState, BLACK_CAL);
      if (readState == 0)
        runState++;
      break;

    case 1: // calibrate white
      readState = fsmReadValue(readState, WHITE_CAL);
      if (readState == 0)
        runState++;
      break;


    case 2: // output the text data
      outputHeader();
      runState++;
      break;

    default:
      runState = 0; // start again if we get here as something is wrong
  }
}
